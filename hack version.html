<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game Hub: Hard Mode</title>
    <style>
        :root {
            --primary: #0a66c2;
            --accent: #ff5722;
            --success: #057642;
            --warn: #e6b800;
            --bg: #f3f2ef;
            --card: #ffffff;
            --text: #191919;
            --wrong: #c20a0a;
            --path-color: #ff5722;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg); margin: 0; padding: 0;
            overflow: hidden; touch-action: none;
            color: var(--text); height: 100vh; display: flex; flex-direction: column;
        }

        header {
            background: var(--card); padding: 8px; flex-shrink: 0;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1); text-align: center; z-index: 100;
        }
        .timer-display { font-size: 1.1rem; font-weight: 700; color: var(--primary); margin-bottom: 5px; }
        .nav-scroller { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 4px; justify-content: flex-start; scrollbar-width: none; }
        .nav-scroller::-webkit-scrollbar { display: none; }

        button.nav-btn {
            padding: 6px 14px; border-radius: 16px; border: 1px solid var(--primary);
            background: var(--card); color: var(--primary); font-weight: 600;
            cursor: pointer; transition: all 0.2s; font-size: 0.85rem; white-space: nowrap; flex-shrink: 0;
        }
        button.nav-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        .game-screen {
            display: none; flex-direction: column; align-items: center;
            flex: 1; width: 100%; padding: 10px;
            overflow: hidden; position: relative;
        }
        .game-screen.active { display: flex; }

        h3 { margin: 5px 0 10px 0; font-size: 1rem; color: #444; flex-shrink: 0; }

        .game-board-container {
            flex: 1; display: flex; justify-content: center; align-items: center; width: 100%;
            min-height: 0; position: relative;
        }

        .controls {
            margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; width: 100%;
            padding-bottom: 10px; flex-shrink: 0;
        }

        button.action-btn {
            background: var(--primary); color: white; border: none; padding: 12px 18px;
            border-radius: 8px; font-weight: 600; font-size: 1rem; cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        button.action-btn:active { transform: scale(0.96); }
        button.action-btn.secondary { background: #666; }
        button.action-btn.tip { background: var(--warn); color: black; }
        button.action-btn.giveup { background: var(--wrong); color: white; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.75); z-index: 999; align-items: center; justify-content: center; }
        .modal-content { background: white; padding: 25px; border-radius: 12px; max-width: 85%; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .modal h2 { margin-top: 0; color: var(--primary); }

        .puzzle-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;
            background: #e0e0e0; padding: 5px; border-radius: 8px;
            width: 100%; max-width: 320px; aspect-ratio: 1/1;
        }
        .tile {
            background: var(--primary); color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; font-weight: bold; border-radius: 6px;
            cursor: pointer; user-select: none; transition: background-color 0.2s, transform 0.2s;
        }
        .tile.empty { background: transparent; cursor: default; }
        .tile.hint { background-color: var(--warn); transform: scale(1.05); }

        .fill-grid {
            width: 100%; max-width: 340px; aspect-ratio: 1/1;
            background: #fff; border-radius: 8px; padding: 5px;
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .fill-cell {
            background: #f0f2f5; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.2rem; color: var(--primary);
            cursor: pointer; user-select: none; transition: all 0.2s;
        }
        .fill-cell.filled { background: var(--primary); color: white; }
        .fill-cell.current { background: var(--accent); color: white; box-shadow: 0 0 0 3px var(--accent); z-index: 2; }
        .fill-cell.valid { background-color: #d0e0fc; }

        .code-game-layout {
            display: flex; flex-direction: column;
            width: 100%; max-width: 400px;
            flex: 1;
            min-height: 0;
            background: white; border-radius: 12px; padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .history-container {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #eee; border-radius: 8px;
            margin-bottom: 10px; padding: 5px;
            background: #fafafa;
            display: flex; flex-direction: column;
        }
        .history-container::-webkit-scrollbar { width: 8px; }
        .history-container::-webkit-scrollbar-track { background: #f1f1f1; }
        .history-container::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }

        .guess-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 10px; border-bottom: 1px solid #ddd; background: white; margin-bottom: 4px; border-radius: 4px;
            flex-shrink: 0;
        }
        .guess-nums { font-family: monospace; font-size: 1.5rem; font-weight: 800; letter-spacing: 5px; color: #000; }
        .guess-dots { display: flex; gap: 6px; }
        .res-dot { width: 14px; height: 14px; border-radius: 50%; background: #e0e0e0; }
        .res-dot.g { background: var(--success); }
        .res-dot.y { background: var(--warn); }

        .code-bottom-panel { flex-shrink: 0; }

        .input-display {
            display: flex; gap: 10px; justify-content: center; padding: 10px;
            background: #eef3f8; border-radius: 8px; margin-bottom: 10px;
        }
        .input-slot {
            width: 45px; height: 50px; border-bottom: 4px solid var(--primary);
            display: flex; align-items: center; justify-content: center;
            font-size: 1.8rem; font-weight: 800; background: white;
            border-radius: 4px 4px 0 0; color: #000;
        }

        .keypad { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-bottom: 10px; }
        .key {
            padding: 15px 0; background: #f0f2f5; border: 1px solid #ddd;
            border-radius: 6px; font-weight: 700; font-size: 1.2rem;
            cursor: pointer; color: #000;
        }
        .key:active { background: #d0d0d0; }
        .key.disabled { opacity: 0.3; pointer-events: none; }

        .reward-screen {
            display: none; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; height: 100%; width: 100%;
            background: white; border-radius: 12px; z-index: 10;
        }
        .reward-screen.active { display: flex; }
        .reward-content { margin: 20px 0; font-size: 1.2rem; font-weight: bold; color: var(--accent); }
        .reward-img { max-width: 90%; max-height: 200px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }

        .path-board {
            width: 100%; max-width: 380px; aspect-ratio: 1/1;
            position: relative; touch-action: none; user-select: none;
            background: white; border-radius: 10px; box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            margin: auto;
        }
        .path-grid-layer {
            display: grid; width: 100%; height: 100%;
            position: absolute; top: 0; left: 0;
        }
        .path-cell {
            border: 1px solid #f8f8f8;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .num-circle {
            width: 70%; height: 70%; border-radius: 50%; background: #e0e0e0; color: #555;
            display: flex; align-items: center; justify-content: center;
            font-weight: 800; font-size: 1.1rem; position: relative; z-index: 2;
        }
        .num-circle.target { background: var(--path-color); color: white; box-shadow: 0 0 0 3px #ffccbc; transform: scale(1.1); }
        .num-circle.start { background: var(--path-color); color: white; }
        .num-circle.done { background: var(--path-color); color: white; opacity: 0.9; }

        #path-svg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1;
        }
        .path-line {
            stroke: var(--path-color); stroke-width: 30%;
            stroke-linecap: round; stroke-linejoin: round; fill: none; opacity: 0.8;
        }
        .path-line-preview {
            stroke: var(--path-color); stroke-width: 30%;
            stroke-linecap: round; stroke-linejoin: round; fill: none; opacity: 0.4;
        }
    </style>
</head>
<body>

<header>
    <div class="timer-display">‚è±Ô∏è <span id="global-timer">00:00</span></div>
    <nav class="nav-scroller">
        <button class="nav-btn active" onclick="switchGame('slide')">Slide Puzzle</button>
        <button class="nav-btn" onclick="switchGame('fill')">Fill Boxes</button>
        <button class="nav-btn" onclick="switchGame('code')">Code Breaker</button>
        <button class="nav-btn" onclick="switchGame('path')">Path Link</button>
    </nav>
</header>

<div id="modal" class="modal" onclick="closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <h2 id="modal-title">Message</h2>
        <p id="modal-text">...</p>
        <button class="action-btn" onclick="closeModal()">Close</button>
    </div>
</div>

<div id="game-slide" class="game-screen active">
    <h3>Order tiles 1 to 8</h3>
    <div class="game-board-container">
        <div class="puzzle-grid" id="slide-board"></div>
    </div>
    <div class="controls">
        <button class="action-btn" onclick="initSlide()">Shuffle</button>
        <button class="action-btn tip" onclick="slideTip()">üí° Tip</button>
    </div>
</div>

<div id="game-fill" class="game-screen">
    <h3 id="fill-msg">Fill all 25 squares in order!</h3>
    <div class="game-board-container">
        <div class="fill-grid" id="fill-board"></div>
    </div>
    <div class="controls">
        <button class="action-btn" onclick="undoFill()">Undo</button>
        <button class="action-btn secondary" onclick="initFill()">Restart</button>
    </div>
</div>

<div id="game-code" class="game-screen">
    <h3>Crack the 4-digit code</h3>

    <div class="reward-screen" id="code-reward">
        <h2>üéâ Code Cracked! üéâ</h2>
        <div id="reward-content" class="reward-content"></div>
        <button class="action-btn" onclick="resetCodeGame()">Play Again</button>
    </div>

    <div class="code-game-layout" id="code-game-ui">
        <div class="history-container" id="code-history"></div>

        <div class="code-bottom-panel">
            <div class="input-display">
                <div id="slot-0" class="input-slot"></div>
                <div id="slot-1" class="input-slot"></div>
                <div id="slot-2" class="input-slot"></div>
                <div id="slot-3" class="input-slot"></div>
            </div>
            <div class="keypad" id="code-keypad"></div>
            <div style="display:flex; gap:8px;">
                <button class="action-btn secondary" onclick="codeBackspace()" style="flex:1">‚å´</button>
                <button class="action-btn" onclick="codeSubmit()" style="flex:1; background: var(--success);">ENTER</button>
            </div>
        </div>
    </div>

    <div class="controls" id="code-controls">
        <button class="action-btn" onclick="initCode()">Reset</button>
        <button class="action-btn tip" onclick="codeTip()">üí° Next Guess</button>
        <button class="action-btn giveup" onclick="codeGiveUp()">Give Up</button>
    </div>
</div>

<div id="game-path" class="game-screen">
    <h3 id="path-msg">Drag to connect 1 ‚Üí 2 ‚Üí 3...</h3>
    <div class="game-board-container">
        <div class="path-board" id="path-board-touch">
            <div class="path-grid-layer" id="path-grid"></div>
            <svg id="path-svg-layer"></svg>
        </div>
    </div>
    <div class="controls">
        <button class="action-btn secondary" onclick="pathPrev()">Prev</button>
        <button class="action-btn" onclick="resetPathLevel()">Retry</button>
        <button class="action-btn secondary" onclick="pathNext()">Next</button>
    </div>
</div>

<script>
    // --- SYSTEM CORE ---
    let timerInt, startTime;
    let gameActive = false;

    function startSystem() {
        stopSystem();
        startTime = Date.now();
        gameActive = true;
        timerInt = setInterval(() => {
            const e = Math.floor((Date.now() - startTime)/1000);
            const m = String(Math.floor(e/60)).padStart(2,'0');
            const s = String(e%60).padStart(2,'0');
            document.getElementById('global-timer').innerText = `${m}:${s}`;
        }, 1000);
    }
    function stopSystem() { gameActive = false; if(timerInt) clearInterval(timerInt); }

    function switchGame(id) {
        document.querySelectorAll('.game-screen').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(e => e.classList.remove('active'));

        document.getElementById(`game-${id}`).classList.add('active');
        const idx = ['slide','fill','code','path'].indexOf(id);
        document.querySelectorAll('.nav-btn')[idx].classList.add('active');

        if(id === 'slide') initSlide();
        if(id === 'fill') initFill();
        if(id === 'code') initCode();
        if(id === 'path') initPathGame();
    }

    function showModal(title, text) {
        document.getElementById('modal-title').innerText = title;
        document.getElementById('modal-text').innerHTML = text;
        document.getElementById('modal').style.display = 'flex';
    }
    function closeModal() { document.getElementById('modal').style.display = 'none'; }


    // ==========================================
    // GAME 1: SLIDE PUZZLE
    // ==========================================
    let slideTiles = [];
    function initSlide() {
        startSystem();
        slideTiles = [1,2,3,4,5,6,7,8,null];
        let empty = 8;
        for(let i=0; i<120; i++) {
            const neighbors = [];
            if(empty % 3 > 0) neighbors.push(empty-1);
            if(empty % 3 < 2) neighbors.push(empty+1);
            if(empty >= 3) neighbors.push(empty-3);
            if(empty < 6) neighbors.push(empty+3);
            const move = neighbors[Math.floor(Math.random()*neighbors.length)];
            [slideTiles[empty], slideTiles[move]] = [slideTiles[move], slideTiles[empty]];
            empty = move;
        }
        renderSlide();
    }

    function renderSlide() {
        const b = document.getElementById('slide-board');
        b.innerHTML = '';
        slideTiles.forEach((t, i) => {
            const d = document.createElement('div');
            d.className = `tile ${t===null?'empty':''}`;
            d.innerText = t || '';
            d.id = `stile-${i}`;
            d.onpointerdown = () => slideMove(i);
            b.appendChild(d);
        });
    }

    function slideMove(i) {
        if(!gameActive) return;
        const e = slideTiles.indexOf(null);
        const diff = Math.abs(i-e);
        if ((diff===1 && Math.floor(i/3)===Math.floor(e/3)) || diff===3) {
            [slideTiles[i], slideTiles[e]] = [slideTiles[e], slideTiles[i]];
            renderSlide();
            if(slideTiles.join(',') === "1,2,3,4,5,6,7,8,") {
                stopSystem();
                showModal("Winner!", `Puzzle Solved in ${document.getElementById('global-timer').innerText}!`);
            }
        }
    }

    function slideTip() {
        if(!gameActive) return;
        const e = slideTiles.indexOf(null);
        let target = e>=3 ? e-3 : (e<6 ? e+3 : (e%3>0 ? e-1 : e+1));
        const el = document.getElementById(`stile-${target}`);
        if(el) { el.classList.add('hint'); setTimeout(()=>el.classList.remove('hint'),600); }
    }


    // ==========================================
    // GAME 2: FILL IN BOXES
    // ==========================================
    let fillGrid = [], fillPath = [];
    function initFill() {
        startSystem();
        fillGrid = Array(25).fill(0);
        const start = Math.floor(Math.random()*25);
        fillGrid[start] = 1;
        fillPath = [start];
        document.getElementById('fill-msg').innerText = "Fill all 25 squares in order!";
        renderFill();
    }

    function renderFill() {
        const b = document.getElementById('fill-board');
        b.innerHTML = '';
        const head = fillPath[fillPath.length-1];
        const r_head = Math.floor(head/5), c_head = head%5;

        for(let i=0; i<25; i++) {
            const d = document.createElement('div');
            d.className = 'fill-cell';
            const val = fillGrid[i];
            if(val > 0) {
                d.innerText = val;
                d.classList.add('filled');
                if(i === head) d.classList.add('current');
            } else {
                const r = Math.floor(i/5), c = i%5;
                if(gameActive && Math.abs(r-r_head)+Math.abs(c-c_head) === 1) d.classList.add('valid');
            }
            d.onpointerdown = () => fillClick(i);
            b.appendChild(d);
        }
    }

    function fillClick(i) {
        if(!gameActive) return;
        const head = fillPath[fillPath.length-1];
        const r1 = Math.floor(head/5), c1 = head%5;
        const r2 = Math.floor(i/5), c2 = i%5;

        if(fillGrid[i] === 0 && Math.abs(r1-r2)+Math.abs(c1-c2) === 1) {
            const nextVal = fillPath.length + 1;
            fillGrid[i] = nextVal;
            fillPath.push(i);
            renderFill();
            if(nextVal === 25) {
                stopSystem();
                showModal("Congrats!", "You filled the board!");
            }
        }
    }

    function undoFill() {
        if(!gameActive || fillPath.length <= 1) return;
        const i = fillPath.pop();
        fillGrid[i] = 0;
        renderFill();
    }


    // ==========================================
    // GAME 3: CODE BREAKER (HARD MODE - BULLS & COWS)
    // ==========================================
    let secret = [], guess = [];

    // Solver state (no cheating: uses history only)
    let codeHistory = [];   // { g:[..], bulls, cows }
    let candidates = [];    // remaining possible codes

    const rewards = [
        {type:'text', content:'SECRET: "The key is patience."'},
        {type:'text', content:'LUCKY NUMBER: 777'},
        {type:'image', content:'https://picsum.photos/id/237/300/200', alt:'Cute Dog'},
        {type:'image', content:'https://picsum.photos/id/1025/300/200', alt:'Pug'},
        {type:'image', content:'https://picsum.photos/id/1062/300/200', alt:'Cozy'}
    ];

    // --- Bulls & Cows evaluator (supports repeated digits) ---
    function evalBC(guessArr, secretArr) {
        let bulls = 0, cows = 0;

        const sCount = Array(10).fill(0);
        const gCount = Array(10).fill(0);

        for (let i = 0; i < 4; i++) {
            if (guessArr[i] === secretArr[i]) {
                bulls++;
            } else {
                sCount[secretArr[i]]++;
                gCount[guessArr[i]]++;
            }
        }

        for (let d = 0; d < 10; d++) cows += Math.min(sCount[d], gCount[d]);
        return { bulls, cows };
    }

    // --- Generate all 10^4 codes (0000..9999) ---
    function genAllCodes() {
        const all = [];
        for (let a = 0; a < 10; a++)
            for (let b = 0; b < 10; b++)
                for (let c = 0; c < 10; c++)
                    for (let d = 0; d < 10; d++)
                        all.push([a, b, c, d]);
        return all;
    }

    // --- Filter possible secrets based on all past feedback ---
    function filterCandidates(all, history) {
        return all.filter(code => {
            for (const h of history) {
                const r = evalBC(h.g, code);
                if (r.bulls !== h.bulls || r.cows !== h.cows) return false;
            }
            return true;
        });
    }

    // --- Pick a good next guess (fast heuristic minimax-ish by sampling) ---
    function chooseNextGuess(cands, history) {
        if (cands.length === 0) return null;

        if (history.length === 0) return [0, 1, 2, 3];
        if (cands.length <= 25) return cands[0];

        const pool = [];
        const sampleSize = Math.min(250, cands.length);

        for (let i = 0; i < sampleSize; i++) {
            pool.push(cands[Math.floor(Math.random() * cands.length)]);
        }
        for (let i = 0; i < 50; i++) {
            pool.push([
                Math.floor(Math.random()*10),
                Math.floor(Math.random()*10),
                Math.floor(Math.random()*10),
                Math.floor(Math.random()*10)
            ]);
        }

        let bestGuess = pool[0];
        let bestScore = Infinity;

        for (const g of pool) {
            const buckets = new Map();
            for (const s of cands) {
                const r = evalBC(g, s);
                const key = `${r.bulls}-${r.cows}`;
                buckets.set(key, (buckets.get(key) || 0) + 1);
            }
            let worst = 0;
            for (const v of buckets.values()) worst = Math.max(worst, v);

            if (worst < bestScore) {
                bestScore = worst;
                bestGuess = g;
            }
        }

        return bestGuess;
    }

    // --- Fair hint: suggests next guess WITHOUT peeking at secret ---
    function codeHintNextGuess() {
        if (!gameActive) return;

        if (codeHistory.length === 0 && candidates.length === 0) {
            candidates = genAllCodes();
        } else {
            if (candidates.length === 0) candidates = genAllCodes();
            candidates = filterCandidates(candidates, codeHistory);
        }

        const next = chooseNextGuess(candidates, codeHistory);
        if (!next) {
            showModal("Hint", "No valid codes left (history may be inconsistent). Try Reset.");
            return;
        }

        guess = [...next];
        updateCodeUI();

        showModal("Hint", `Try <b>${next.join('')}</b><br>Possible codes left: <b>${candidates.length}</b>`);
    }

    function initCode() {
        startSystem();
        secret = Array.from({length:4},()=>Math.floor(Math.random()*10));
        guess = [];

        codeHistory = [];
        candidates = [];

        document.getElementById('code-history').innerHTML = '';
        document.getElementById('code-game-ui').style.display = 'flex';
        document.getElementById('code-controls').style.display = 'flex';
        document.getElementById('code-reward').classList.remove('active');
        renderCodeKeypad();
        updateCodeUI();
        // console.log(secret); // (keep off for real hard mode)
    }

    function renderCodeKeypad() {
        const k = document.getElementById('code-keypad');
        k.innerHTML = '';
        for(let i=0; i<10; i++) {
            const b = document.createElement('button');
            b.className = 'key'; b.innerText = i; b.id = `key-${i}`;
            b.onclick = () => { if(gameActive && guess.length<4) { guess.push(i); updateCodeUI(); }};
            k.appendChild(b);
        }
    }

    function updateCodeUI() {
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i}`);
            el.innerText = guess[i] !== undefined ? guess[i] : '';
            el.style.color = 'black';
            el.style.borderColor = 'var(--primary)';
        }
    }

    function codeBackspace() { if(gameActive && guess.length>0) { guess.pop(); updateCodeUI(); } }

    function codeSubmit() {
        if(!gameActive || guess.length !== 4) return;

        // Bulls & Cows vs true secret (game feedback)
        const r = evalBC(guess, secret);
        const bulls = r.bulls;
        const cows = r.cows;

        // Store into deduction history (for solver/hints)
        codeHistory.push({ g: [...guess], bulls, cows });

        // Narrow candidates immediately (so hint is faster next time)
        if (candidates.length === 0) candidates = genAllCodes();
        candidates = filterCandidates(candidates, codeHistory);

        // Render History Entry
        const h = document.getElementById('code-history');
        const row = document.createElement('div');
        row.className = 'guess-row';

        let dotsHtml = '';
        for(let i=0; i<bulls; i++) dotsHtml += `<div class="res-dot g"></div>`;
        for(let i=0; i<cows; i++) dotsHtml += `<div class="res-dot y"></div>`;

        row.innerHTML = `<div class="guess-nums">${guess.join('')}</div>
                         <div class="guess-dots">${dotsHtml}</div>`;

        h.prepend(row);
        h.scrollTop = 0;

        if(bulls === 4) {
            stopSystem();
            showReward();
        } else {
            guess = [];
            updateCodeUI();
        }
    }

    function showReward() {
        document.getElementById('code-game-ui').style.display = 'none';
        document.getElementById('code-controls').style.display = 'none';
        const scr = document.getElementById('code-reward');
        scr.classList.add('active');
        const r = rewards[Math.floor(Math.random()*rewards.length)];
        const rc = document.getElementById('reward-content');
        rc.innerHTML = r.type === 'text' ? r.content : `<img src="${r.content}" alt="${r.alt}" class="reward-img">`;
    }

    function resetCodeGame() { initCode(); }

    // This tip is now "fair": it does NOT look at secret.
    function codeTip() {
        codeHintNextGuess();
    }

    function codeGiveUp() {
        if(!gameActive) return;
        stopSystem();
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i}`);
            el.innerText = secret[i];
            el.style.color = 'var(--wrong)';
        }
    }


    // ==========================================
    // GAME 4: PATH LINK
    // ==========================================
    const pathLevels = [
        { w:5, h:5, nums:{0:1, 6:2, 12:3, 18:4, 24:5}, max:5 },
        { w:6, h:6, nums:{0:1, 5:2, 30:3, 35:4, 14:5, 21:6}, max:6 },
        { w:5, h:5, nums:{2:1, 10:2, 22:3, 14:4, 6:5, 0:6}, max:6 },
        { w:6, h:6, nums:{1:1, 8:2, 2:3, 15:4, 28:5, 21:6, 34:7, 27:8}, max:8 },
        { w:6, h:6, nums:{0:1, 3:2, 15:3, 12:4, 24:5, 27:6, 35:7, 32:8, 20:9, 23:10}, max:10 },
        { w:5, h:5, nums:{12:1, 7:2, 2:3, 1:4, 5:5, 10:6, 15:7, 20:8, 23:9, 18:10, 13:11, 8:12}, max:12 }
    ];

    let pState = { lvl:0, gridW:0, gridH:0, nums:{}, maxNum:0, currTarget:0, completedPaths:[], activePath:[], isDragging:false };

    function initPathGame() { loadPathLevel(pState.lvl); }
    function pathNext() { if(pState.lvl < pathLevels.length-1) { pState.lvl++; loadPathLevel(pState.lvl); }}
    function pathPrev() { if(pState.lvl > 0) { pState.lvl--; loadPathLevel(pState.lvl); }}
    function resetPathLevel() { loadPathLevel(pState.lvl); }

    function loadPathLevel(idx) {
        startSystem();
        const lvl = pathLevels[idx];
        pState = { ...pState, lvl:idx, gridW:lvl.w, gridH:lvl.h, nums:lvl.nums, maxNum:lvl.max, currTarget:2, completedPaths:[], activePath:[], isDragging:false };

        document.getElementById('path-msg').innerText = `Level ${idx+1}: Connect 1 to 2, then 2 to 3...`;
        renderPathBoard();
    }

    function renderPathBoard() {
        const gridLayer = document.getElementById('path-grid');
        gridLayer.innerHTML = '';
        gridLayer.style.gridTemplateColumns = `repeat(${pState.gridW}, 1fr)`;

        const touchLayer = document.getElementById('path-board-touch');
        touchLayer.onpointerdown = pathDown;
        touchLayer.onpointermove = pathMove;
        touchLayer.onpointerup = pathUp;
        touchLayer.onpointercancel = pathUp;

        for(let i=0; i<pState.gridW*pState.gridH; i++) {
            const cell = document.createElement('div');
            cell.className = 'path-cell'; cell.dataset.idx = i;
            if(pState.nums[i]) {
                const num = pState.nums[i];
                const circ = document.createElement('div');
                circ.className = 'num-circle';
                circ.innerText = num;
                if(num === pState.currTarget) circ.classList.add('target');
                if(num === pState.currTarget - 1) circ.classList.add('start');
                if(num < pState.currTarget - 1) circ.classList.add('done');
                cell.appendChild(circ);
            }
            gridLayer.appendChild(cell);
        }
        renderPathSvg();
    }

    function renderPathSvg() {
        const svg = document.getElementById('path-svg-layer');
        svg.innerHTML = '';
        const grid = document.getElementById('path-grid');
        if(!grid.children[0]) return;
        const rect = grid.getBoundingClientRect();
        const cellW = rect.width / pState.gridW;
        const cellH = rect.height / pState.gridH;

        const getCoords = (idx) => {
             const r = Math.floor(idx/pState.gridW), c = idx%pState.gridW;
             return { x: c*cellW + cellW/2, y: r*cellH + cellH/2 };
        };

        const makePathStr = (indices) => {
            return indices.map((idx, i) => {
                const pos = getCoords(idx);
                return `${i===0?'M':'L'} ${pos.x} ${pos.y}`;
            }).join(' ');
        };

        pState.completedPaths.forEach(path => {
            const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathEl.setAttribute('d', makePathStr(path));
            pathEl.setAttribute('class', 'path-line');
            svg.appendChild(pathEl);
        });

        if(pState.activePath.length > 1) {
             const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
             pathEl.setAttribute('d', makePathStr(pState.activePath));
             pathEl.setAttribute('class', 'path-line-preview');
             svg.appendChild(pathEl);
        }
    }

    function pathDown(e) {
        if(!gameActive) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const cell = el?.closest('.path-cell');
        if(!cell) return;

        const idx = parseInt(cell.dataset.idx);
        const num = pState.nums[idx];

        if(num === pState.currTarget - 1) {
            pState.isDragging = true;
            pState.activePath = [idx];
            renderPathSvg();
            cell.setPointerCapture(e.pointerId);
        }
    }

    function pathMove(e) {
        if(!pState.isDragging) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const cell = el?.closest('.path-cell');
        if(!cell) return;

        const idx = parseInt(cell.dataset.idx);
        const lastIdx = pState.activePath[pState.activePath.length-1];

        if(idx === lastIdx) return;

        if(pState.activePath.length > 1 && idx === pState.activePath[pState.activePath.length-2]) {
            pState.activePath.pop();
            renderPathSvg();
            return;
        }

        const r1 = Math.floor(lastIdx/pState.gridW), c1 = lastIdx%pState.gridW;
        const r2 = Math.floor(idx/pState.gridW), c2 = idx%pState.gridW;
        if(Math.abs(r1-r2) + Math.abs(c1-c2) !== 1) return;

        const isOccupied = pState.completedPaths.some(p => p.includes(idx)) || pState.activePath.includes(idx);
        if(isOccupied) return;

        const num = pState.nums[idx];
        if(num && num !== pState.currTarget) return;

        pState.activePath.push(idx);
        renderPathSvg();

        if(num === pState.currTarget) pathUp(e);
    }

    function pathUp(e) {
        if(!pState.isDragging) return;
        pState.isDragging = false;

        const lastIdx = pState.activePath[pState.activePath.length-1];
        if(pState.nums[lastIdx] === pState.currTarget) {
            pState.completedPaths.push([...pState.activePath]);
            pState.activePath = [];
            pState.currTarget++;

            if(pState.currTarget > pState.maxNum) {
                const filledCount = new Set(pState.completedPaths.flat()).size;
                if(filledCount === pState.gridW * pState.gridH) {
                     stopSystem();
                     showModal("Perfect!", "Level Complete! Grid Filled.");
                } else {
                     showModal("Almost!", "Numbers connected, but grid NOT full. Try again!");
                }
            }
        } else {
            pState.activePath = [];
        }
        renderPathBoard();
    }

    switchGame('slide');
</script>
</body>
</html>
